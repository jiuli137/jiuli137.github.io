<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RSA入门</title>
      <link href="/2024/12/08/2025-RSA%E5%85%A5%E9%97%A8/"/>
      <url>/2024/12/08/2025-RSA%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="一、非对称加密的概念与原理"><a href="#一、非对称加密的概念与原理" class="headerlink" title="一、非对称加密的概念与原理"></a>一、非对称加密的概念与原理</h2><h3 id="（一）对称加密的困境"><a href="#（一）对称加密的困境" class="headerlink" title="（一）对称加密的困境"></a>（一）对称加密的困境</h3><p>传统的加密算法采用同一密钥进行加密和解密，这种方式被称为对称加密。在对称加密中，通信双方必须事先约定好密钥，并且要确保密钥的安全。然而，在不安全的通信环境中，密钥的传输和存储都面临着巨大的风险。一旦密钥泄露，即使加密算法再严密，信息也会被轻易破解。</p><h3 id="（二）非对称加密的解决方案"><a href="#（二）非对称加密的解决方案" class="headerlink" title="（二）非对称加密的解决方案"></a>（二）非对称加密的解决方案</h3><p>为了解决对称加密的问题，非对称加密应运而生。非对称加密算法拥有两组密钥：<br>公开密钥（Public key，简称 Pk）：又称公钥，可以公开给所有人进行存储。<br>私有密钥（Secret key，简称 Sk）：又称私钥，只能由发送者自己妥善保存。<br>在通信过程中，发送者使用接收者的公钥对信息进行加密，然后将密文发送给接收者。接收者收到密文后，使用自己的私钥进行解密。由于私钥只有接收者拥有，即使中间节点获取了密文，也无法解密，从而保证了信息的保密性。</p><h3 id="（三）数字签名与身份验证"><a href="#（三）数字签名与身份验证" class="headerlink" title="（三）数字签名与身份验证"></a>（三）数字签名与身份验证</h3><p>非对称加密不仅可以保证信息的保密性，还可以通过数字签名实现身份验证和信息完整性的验证。发送者使用自己的私钥对数据进行签名，接收者使用发送者的公钥进行验签。如果验签成功，就可以证明数据是由发送者发送的，并且在传输过程中没有被篡改。</p><h2 id="二、RSA-算法"><a href="#二、RSA-算法" class="headerlink" title="二、RSA 算法"></a>二、RSA 算法</h2><h3 id="（三）RSA-算法的工作流程"><a href="#（三）RSA-算法的工作流程" class="headerlink" title="（三）RSA 算法的工作流程"></a>（三）RSA 算法的工作流程</h3><p>选取两个不同的大素数(p)和(q)，计算(N = p \cdot q) </p><p>求欧拉函数值(\varphi(N)=\varphi(p)\varphi(q)=(p - 1)(q - 1))</p><p>选择一个小于(\varphi(N))的整数(e)，并且满足(e)和(\varphi(N))互质，求得(e)在模(\varphi(N))意义下的乘法逆元(d)，使得(ed\equiv1\pmod{\varphi(N)})</p>]]></content>
      
      
      <categories>
          
          <category> crypto - record </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开启记录之旅</title>
      <link href="/2024/12/03/2024-crypto-wp-%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/12/03/2024-crypto-wp-%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<!-- ---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前--- --><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这算是真正的第一篇文章，此分类主要致力于记录我参与或复现各类比赛的题目，同时也会记下我在过程中遭遇的问题以及突发的奇思妙想。倘若存在错误或者有其他更佳的思路,热烈欢迎各位师傅予以指正。</p><p>我也学习一下鸡块师傅的做法：</p><ul><li>赛中做出的题目,名字无变化。</li><li>赛中未做出赛后复现的标 *。</li><li>赛中未做出，赛后也没有思路的标 $。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> crypto - write_up </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-强网杯-wp</title>
      <link href="/2024/12/03/2024-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/"/>
      <url>/2024/12/03/2024-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="EasyRSA"><a href="#EasyRSA" class="headerlink" title="EasyRSA"></a>EasyRSA</h2><p>题目描述：</p><pre><code>easy的RSA。</code></pre><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#encoding:utf-8</span><br><span class="line">from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime</span><br><span class="line">import random, gmpy2</span><br><span class="line"></span><br><span class="line">class RSAEncryptor:</span><br><span class="line">def __init__(self):</span><br><span class="line">self.g = self.a = self.b = 0</span><br><span class="line">self.e = 65537</span><br><span class="line">self.factorGen()</span><br><span class="line">self.product()</span><br><span class="line"></span><br><span class="line">def factorGen(self):</span><br><span class="line">while True:</span><br><span class="line">self.g = getPrime(500)</span><br><span class="line">while not gmpy2.is_prime(2*self.g*self.a+1):</span><br><span class="line">self.a = random.randint(2**523, 2**524)</span><br><span class="line">while not gmpy2.is_prime(2*self.g*self.b+1):</span><br><span class="line">self.b = random.randint(2**523, 2**524)</span><br><span class="line">self.h = 2*self.g*self.a*self.b+self.a+self.b</span><br><span class="line">if gmpy2.is_prime(self.h):</span><br><span class="line">self.N = 2*self.h*self.g+1</span><br><span class="line">print(len(bin(self.N)))</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">def encrypt(self, msg):</span><br><span class="line">return gmpy2.powmod(msg, self.e, self.N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def product(self):</span><br><span class="line">with open(&#x27;/flag&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">self.flag = f.read()</span><br><span class="line">self.enc = self.encrypt(self.flag)</span><br><span class="line">self.show()</span><br><span class="line">print(f&#x27;enc=&#123;self.enc&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">print(f&quot;N=&#123;self.N&#125;&quot;)</span><br><span class="line">print(f&quot;e=&#123;self.e&#125;&quot;)</span><br><span class="line">print(f&quot;g=&#123;self.g&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RSAEncryptor()</span><br></pre></td></tr></table></figure><p>其中有：</p><pre><code>            p = 2ga + 1            q = 2gb + 1</code></pre><p>很明显的Common Prime RSA攻击,又因为泄露了g，找到解密脚本直接套用即可</p><p><a href="https://hasegawaazusa.github.io/common-prime-rsa.html#%E5%B7%B2%E7%9F%A5-g" style="color: blue; text-decoration: underline;">Common Prime RSA 笔记 | 独奏の小屋 (hasegawaazusa.github.io)</a></p><p>因为这个博客的时间有点久了，sage版本比较老，bags的参数有点问题，参考sage的官方文档改一下bsgs参数就好。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#sage</span><br><span class="line">n=18609249586511447022929188601029606630816796460795187470065452150283160549624372398383148374249992521068549349516037511009027303530058706112191091689108542770802393390942693648814845389265858611340109158309645284100825624911741650444467173946569096983438455034895955228543351436008546035535031019474847660151534447157873386841134028651786166708821300066332734338450150803713659027324704224480646285707278634645234095122804559045312923819794776928194098487972764363649361713512731460059740929840789043447155551107435766468071813945331313861835289050624825980714650042186547867057986370794200778277570803957071502251887</span><br><span class="line">e=65537</span><br><span class="line">g=2157382166227048008151606160068683153029902706798753603550075684775242674106840467207794609506075603345430902709796320595040305496549488048759451499003</span><br><span class="line">enc=1706676139782916859705617140716929473350550599143215409850324617375385155893376548401557158261122335220199922229225746433590875391358929714141838314015655361989993985070285957305126847445442699828095001203266978036575956723172054402632901673504599481917025056824986547174258708944098866240451432510310007060414500907941107101001004474036283249456230343043785187819423163986135104740039129111213967847515011092231384245986891933365405336421413444499204268699546739391271911481490278065027465465222639265899471823742196086481403499948301061349936225773314002398442541447810628796808530412232638250097430811300924120316</span><br><span class="line">gamma = 500/(1024*2)</span><br><span class="line">cbits = ceil(nbits * (0.5 - 2 * gamma))</span><br><span class="line"></span><br><span class="line">M = (N - 1) // (2 * g)</span><br><span class="line">u = M // (2 * g)</span><br><span class="line">v = M - 2 * g * u</span><br><span class="line">GF = Zmod(N)</span><br><span class="line">x = GF.random_element()</span><br><span class="line">y = x ^ (2 * g)</span><br><span class="line">#c的范围大概与N^(0.5-2*gamma)很接近</span><br><span class="line">c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)</span><br><span class="line">#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)</span><br><span class="line">ab = u - c</span><br><span class="line">apb = v + 2 * g * c</span><br><span class="line">P.&lt;x&gt; = ZZ[]</span><br><span class="line">f = x ^ 2 - apb * x + ab</span><br><span class="line">a = f.roots()</span><br><span class="line">if a:</span><br><span class="line">    a, b = a[0][0], a[1][0]</span><br><span class="line">    p = 2 * g * a + 1</span><br><span class="line">    q = 2 * g * b + 1</span><br><span class="line">    assert p * q == N</span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(long_to_bytes(int(pow(enc,inverse(e,(p-1)*(q-1)),n))))</span><br></pre></td></tr></table></figure><h2 id="apbq"><a href="#apbq" class="headerlink" title="apbq"></a>apbq</h2><p>题目描述：</p><pre><code>I obtained several sets of ap + bq through channel measurement. Can you solve it?</code></pre><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secrets import flag</span><br><span class="line">from math import ceil</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class RSA():</span><br><span class="line">    def __init__(self, privatekey, publickey):</span><br><span class="line">        self.p, self.q, self.d = privatekey</span><br><span class="line">        self.n, self.e = publickey</span><br><span class="line"></span><br><span class="line">    def encrypt(self, plaintext):</span><br><span class="line">        if isinstance(plaintext, bytes):</span><br><span class="line">            plaintext = bytes_to_long(plaintext)</span><br><span class="line">        ciphertext = pow(plaintext, self.e, self.n)</span><br><span class="line">        return ciphertext</span><br><span class="line"></span><br><span class="line">    def decrypt(self, ciphertext):</span><br><span class="line">        if isinstance(ciphertext, bytes):</span><br><span class="line">            ciphertext = bytes_to_long(ciphertext)</span><br><span class="line">        plaintext = pow(ciphertext, self.d, self.n)</span><br><span class="line">        return plaintext</span><br><span class="line"></span><br><span class="line">def get_keypair(nbits, e = 65537):</span><br><span class="line">    p = getPrime(nbits//2)</span><br><span class="line">    q = getPrime(nbits//2)</span><br><span class="line">    n = p * q</span><br><span class="line">    d = inverse(e, n - p - q + 1)</span><br><span class="line">    return (p, q, d), (n, e)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pt = &#x27;./output.txt&#x27;</span><br><span class="line">    fout = open(pt, &#x27;w&#x27;)</span><br><span class="line">    sys.stdout = fout</span><br><span class="line"></span><br><span class="line">    block_size = ceil(len(flag)/3)</span><br><span class="line">    flag = [flag[i:i+block_size] for i in range(0, len(flag), block_size)]</span><br><span class="line">    e = 65537</span><br><span class="line"></span><br><span class="line">    print(f&#x27;[+] Welcome to my apbq game&#x27;)</span><br><span class="line">    # stage 1</span><br><span class="line">    print(f&#x27;┃ stage 1: p + q&#x27;)</span><br><span class="line">    prikey1, pubkey1 = get_keypair(1024)</span><br><span class="line">    RSA1 = RSA(prikey1, pubkey1)</span><br><span class="line">    enc1 = RSA1.encrypt(flag[0])</span><br><span class="line">    print(f&#x27;┃ hints = &#123;prikey1[0] + prikey1[1]&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey1&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc1 = &#123;enc1&#125;&#x27;)</span><br><span class="line">    print(f&#x27;----------------------&#x27;)</span><br><span class="line"></span><br><span class="line">    # stage 2</span><br><span class="line">    print(f&#x27;┃ stage 2: ai*p + bi*q&#x27;)</span><br><span class="line">    prikey2, pubkey2 = get_keypair(1024)</span><br><span class="line">    RSA2 = RSA(prikey2, pubkey2)</span><br><span class="line">    enc2 = RSA2.encrypt(flag[1])</span><br><span class="line">    kbits = 180</span><br><span class="line">    a = [getRandomNBitInteger(kbits) for i in range(100)]</span><br><span class="line">    b = [getRandomNBitInteger(kbits) for i in range(100)]</span><br><span class="line">    c = [a[i]*prikey2[0] + b[i]*prikey2[1] for i in range(100)]</span><br><span class="line">    print(f&#x27;┃ hints = &#123;c&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc2 = &#123;enc2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;----------------------&#x27;)</span><br><span class="line"></span><br><span class="line">    # stage 3</span><br><span class="line">    print(f&#x27;┃ stage 3: a*p + q, p + bq&#x27;)</span><br><span class="line">    prikey3, pubkey3 = get_keypair(1024)</span><br><span class="line">    RSA3 = RSA(prikey3, pubkey3)</span><br><span class="line">    enc3 = RSA2.encrypt(flag[2])</span><br><span class="line">    kbits = 512</span><br><span class="line">    a = getRandomNBitInteger(kbits)</span><br><span class="line">    b = getRandomNBitInteger(kbits)</span><br><span class="line">    c1 = a*prikey3[0] + prikey3[1]</span><br><span class="line">    c2 = prikey3[0] + b*prikey3[1] </span><br><span class="line">    print(f&#x27;┃ hints = &#123;c1, c2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey3&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc3 = &#123;enc3&#125;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>给出了 p + q和n，没什么好说的直接就能解</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">hint1 = 18978581186415161964839647137704633944599150543420658500585655372831779670338724440572792208984183863860898382564328183868786589851370156024615630835636170</span><br><span class="line">n1, e1 = (89839084450618055007900277736741312641844770591346432583302975236097465068572445589385798822593889266430563039645335037061240101688433078717811590377686465973797658355984717210228739793741484666628342039127345855467748247485016133560729063901396973783754780048949709195334690395217112330585431653872523325589, 65537)</span><br><span class="line">enc1 = 23664702267463524872340419776983638860234156620934868573173546937679196743146691156369928738109129704387312263842088573122121751421709842579634121187349747424486233111885687289480494785285701709040663052248336541918235910988178207506008430080621354232140617853327942136965075461701008744432418773880574136247</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(pow(enc1, inverse(e, (n - hint1 + 1)), n1)))) </span><br></pre></td></tr></table></figure><h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3>]]></content>
      
      
      <categories>
          
          <category> crypto - write_up </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
