<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>2024-cryptoctf-wp</title>
      <link href="/2025/03/11/2024-cryptoctf-wp/"/>
      <url>/2025/03/11/2024-cryptoctf-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="Easy"><a href="#Easy" class="headerlink" title="Easy"></a>Easy</h2><h2 id="alibos"><a href="#alibos" class="headerlink" title="alibos"></a>alibos</h2><p>题目描述：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Alibos, a classic cryptographic algorithm, is designed to safeguard non-sensitive data, providing a reliable solution for routine information protection.</span><br></pre></td></tr></table></figure></p><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from secret import d, flag</span><br><span class="line"></span><br><span class="line">get_context().precision = 1337</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def pad(m, d):</span><br><span class="line">    if len(str(m)) &lt; d:</span><br><span class="line">        m = str(m) + &#x27;1&#x27; * (d - len(str(m)))</span><br><span class="line">    return int(m)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def genkey(d):</span><br><span class="line">    skey = getRandomRange(10 ** (d - 1), 10 ** d)</span><br><span class="line">    pkey = int(10 ** d * (sqrt(skey) - floor(sqrt(skey))))</span><br><span class="line">    return pkey, skey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(m, pkey):</span><br><span class="line">    m = pad(m, len(str(pkey)))</span><br><span class="line">    d = len(str(pkey))</span><br><span class="line">    c = (pkey + d ** 2 * m) % (10 ** d)</span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkey, skey = genkey(d)</span><br><span class="line"></span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = encrypt(m, pkey)</span><br><span class="line"></span><br><span class="line">print(f&#x27;pkey = &#123;pkey&#125;&#x27;)</span><br><span class="line">print(f&#x27;enc  = &#123;c&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>output:<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pkey = 8582435512564229286688465405009040056856016872134514945016805951785759509953023638490767572236748566493023965794194297026085882082781147026501124183913218900918532638964014591302221504335115379744625749001902791287122243760312557423006862735120339132655680911213722073949690947638446354528576541717311700749946777</span><br><span class="line">enc  = 6314597738211377086770535291073179315279171595861180001679392971498929017818237394074266448467963648845725270238638741470530326527225591470945568628357663345362977083408459035746665948779559824189070193446347235731566688204757001867451307179564783577100125355658166518394135392082890798973020986161756145194380336</span><br></pre></td></tr></table></figure></p><p>简单来说的是按照如下方式进行加密：<br>$c = \text{pkey} + d^2 \quad (\text{pad}(m)) \quad \text{mod}(10^d)$<br>这里主要是未知d，但是仔细观察题目会发现$d = len(str(pkey))$ 所以d就已知了，直接解即可</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line"></span><br><span class="line">pkey = 8582435512564229286688465405009040056856016872134514945016805951785759509953023638490767572236748566493023965794194297026085882082781147026501124183913218900918532638964014591302221504335115379744625749001902791287122243760312557423006862735120339132655680911213722073949690947638446354528576541717311700749946777</span><br><span class="line">c = 6314597738211377086770535291073179315279171595861180001679392971498929017818237394074266448467963648845725270238638741470530326527225591470945568628357663345362977083408459035746665948779559824189070193446347235731566688204757001867451307179564783577100125355658166518394135392082890798973020986161756145194380336</span><br><span class="line">p_d = len(str(pkey))</span><br><span class="line">mod = 10 ** p_d</span><br><span class="line">m = ((c - pkey) % mod * inverse(p_d ** 2, 10 ** p_d)) % mod</span><br><span class="line">print(m)</span><br><span class="line"># 这里是需要去掉pad所以直接复制出来的数字，也可以写个循环判断flag头</span><br><span class="line">flag = long_to_bytes(</span><br><span class="line">    int(617070432649333612824260819310073660177462690396680303631818904538190359368277582922920090537696854326452605))</span><br><span class="line">print(flag)</span><br><span class="line">#CCTF&#123;h0M3_m4De_cRyp70_5ySTeM_1N_CryptoCTF!!!&#125;</span><br></pre></td></tr></table></figure><h2 id="Mashy"><a href="#Mashy" class="headerlink" title="Mashy"></a>Mashy</h2><p>题目描述：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Mashy may seem like a simple cracking task, but you&#x27;ll need to open your eyes to identify the right things to crack.</span><br></pre></td></tr></table></figure></p><p>题目：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">import sys</span><br><span class="line">from hashlib import md5</span><br><span class="line">from binascii import *</span><br><span class="line">from secret import salt, flag</span><br><span class="line"></span><br><span class="line">def die(*args):</span><br><span class="line">pr(*args)</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">def pr(*args):</span><br><span class="line">s = &quot; &quot;.join(map(str, args))</span><br><span class="line">sys.stdout.write(s + &quot;\n&quot;)</span><br><span class="line">sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def sc():</span><br><span class="line">return sys.stdin.buffer.readline()</span><br><span class="line"></span><br><span class="line">def xor(s1, s2):</span><br><span class="line">return bytes([s1[_] ^ s2[_] for _ in range(len(s1))])</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">border = &quot;┃&quot;</span><br><span class="line">pr(        &quot;┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓&quot;)</span><br><span class="line">pr(border, &quot;.: Hi all, she did Mashy, you should do it too! Are you ready? :. &quot;, border)</span><br><span class="line">pr(        &quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛&quot;)</span><br><span class="line"></span><br><span class="line">REC = []</span><br><span class="line">cnt, STEP = 0, 7</span><br><span class="line">sh = md5(salt).digest()</span><br><span class="line"></span><br><span class="line">while True:</span><br><span class="line">pr(border, f&#x27;Please send your first input:  &#x27;)</span><br><span class="line">d1 = sc().strip()</span><br><span class="line">pr(border, f&#x27;Please send your second input: &#x27;)</span><br><span class="line">d2 = sc().strip()</span><br><span class="line">try:</span><br><span class="line">d1 = hexlify(unhexlify(d1))</span><br><span class="line">d2 = hexlify(unhexlify(d2))</span><br><span class="line">h1 = md5(unhexlify(d1)).digest()</span><br><span class="line">h2 = md5(unhexlify(d2)).digest()</span><br><span class="line">except:</span><br><span class="line">die(border, &#x27;Your inputs are not valid! Bye!!!&#x27;)</span><br><span class="line">if d1 != d2 and d1 not in REC and d2 not in REC:</span><br><span class="line">if md5(xor(d1, d2)).hexdigest() != &#x27;ae09d7510659ca40eda3e45ca70e9606&#x27;:</span><br><span class="line">if hexlify(xor(xor(h1, h2), sh)) == b&#x27;a483b30944cbf762d4a3afc154aad825&#x27;:</span><br><span class="line">REC += [d1, d2]</span><br><span class="line">if cnt == STEP:</span><br><span class="line">die(border, f&#x27;Congrats! the flag: &#123;flag&#125;&#x27;)</span><br><span class="line">pr(border, &#x27;Good job, try next level :P&#x27;)</span><br><span class="line">cnt += 1</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;Your input is not correct! Bye!&#x27;)</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;No this one! Sorry!!&#x27;)</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;Kidding me!? Bye!!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure></p><p>简单来说是要完成七轮挑战，使得输入的两个16进制串d1,d2，使得满足：</p><ul><li>d1 不等于 d2</li><li>d1 xor d2 的md5不为 ae09d7510659ca40eda3e45ca70e9606</li><li>md5(d1) xor md5(d2) xor sh 的值为 a483b30944cbf762d4a3afc154aad825</li></ul><p>这题纯出题人脑子有病，出的莫名其妙的，全靠猜<br>ae09d7510659ca40eda3e45ca70e9606的原像为：b’\x00’ * 256<br>a483b30944cbf762d4a3afc154aad825的原像为：emelinjulca<br>然后我们不知道salt也就是sh，就进行不下去了，其实sh就是emelinjulca，纯就跟出题人脑袋相接才能做<br>（ps； 赛中的时候我人都傻了，然后一看几十解了，就拿emelinjulca试了一下结果真是，真是无了大语了）<br>到这里问题就简单了，整几组前缀进行MD5碰撞就完事了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = remote(&quot;01.cr.yp.toc.tf&quot;,13771)</span><br><span class="line"></span><br><span class="line">msg = [(b&quot;31000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fe11ecc10c7ab8b4fe112d7f29ceb2dae1f39ce7a691488bfb817b7685ad087a162b0ce0ea69b140e7274b44c43f183578392f9719b43d4966c321cc0a10e6fbd002869b42f9fad9eb869dc55d5d349835961b1fd36a0bbe76a9bb5f4f5cc54136dec48d74497bf6579a6bf9721b81078637b429cff958886bd816dc4333a338&quot;,b&quot;31000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000fe11ecc10c7ab8b4fe112d7f29ceb2dae1f39c67a691488bfb817b7685ad087a162b0ce0ea69b140e7274b44c4bf183578392f9719b43d4966c3214c0a10e6fbd002869b42f9fad9eb869dc55d5d349835961b9fd36a0bbe76a9bb5f4f5cc54136dec48d74497bf6579a6bf9729b80078637b429cff958886bd8165c4333a338&quot;),</span><br><span class="line">       (b&quot;32000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ebcd0390c198c8f33b4a08cce32f47451b5002e68895b7505d12824a0a460d133de3eff34e4de89ceb27ed3bce211b4696fec6736c059058d8b60f6e473f6c701068abf2d6bc645c4589a6f0f5211f5fc903c96e789d91f8abb300d8176088b7d31d825897c9001cf409c45b3a50005e93e33f4f908f9df944a664c927d28d55&quot;,b&quot;32000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000ebcd0390c198c8f33b4a08cce32f47451b5002668895b7505d12824a0a460d133de3eff34e4de89ceb27ed3bcea11b4696fec6736c059058d8b60fee473f6c701068abf2d6bc645c4589a6f0f5211f5fc903c9ee789d91f8abb300d8176088b7d31d825897c9001cf409c45b3ad0ff5d93e33f4f908f9df944a6644927d28d55&quot;),</span><br><span class="line">       (b&quot;3300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000068270588dbc19cfe24db79019b0070d1823c4a4d6d816cdb22c2401a32081455e5db01c54c0ccf1b6706f061eec3e58ead12b5173dee55f954f9ac52a1a4bbedc32ab0ee3cae3896f9908a49d38cc5535c6c80661d262e1ec91a8639ecc7e1654086c61bf4cfe7fc6a7378f7809416ef39ae4ccc7fc29570c4c3a51b03fed7b9&quot;,b&quot;3300000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000068270588dbc19cfe24db79019b0070d1823c4acd6d816cdb22c2401a32081455e5db01c54c0ccf1b6706f061ee43e68ead12b5173dee55f954f9acd2a1a4bbedc32ab0ee3cae3896f9908a49d38cc5535c6c80e61d262e1ec91a8639ecc7e1654086c61bf4cfe7fc6a7378f7801416ef39ae4ccc7fc29570c4c3a59b03fed7b9&quot;),</span><br><span class="line">       (b&quot;3400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025a80516e996c87574dc568d274da9d2d281b09bbc72f7ef46767961b4a708e969ebffe06a6e0945cbefe2f2fc41d89cb89c2574afb1fdbac5aca131cdf52d68b9e3c95615888cbc3d187ccd32f60d5b35636e925c1aa3002bb330c81b6088d8cbeb8014afc24f5e374ad05ab2f30d1fac7221195b7f3f1f19f5219ecaf948a2&quot;,b&quot;3400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000025a80516e996c87574dc568d274da9d2d281b01bbc72f7ef46767961b4a708e969ebffe06a6e0945cbefe2f2fcc1d89cb89c2574afb1fdbac5aca1b1cdf52d68b9e3c95615888cbc3d187ccd32f60d5b35636e125c1aa3002bb330c81b6088d8cbeb8014afc24f5e374ad05ab2730d1fac7221195b7f3f1f19f5211ecaf948a2&quot;),</span><br><span class="line">       (b&quot;35000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f56f1da5ad57f483059ae0869962f05204f954e2de9d56c55b168139ec372cefb1b307cbe84ce477cbff5df4d40bc46c08ceef8bb18bfc996b3b9fdaa7b72c17ee1cb3491794d6e2ff7d9914525cdf2d88b9314505ef864d201d2b364a6e25ae4d183e738c3c86e53e5ad1a1910c825cb1bcd59b97d1a3cf979668fbac6a138b&quot;,b&quot;35000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f56f1da5ad57f483059ae0869962f05204f95462de9d56c55b168139ec372cefb1b307cbe84ce477cbff5df4d48bc46c08ceef8bb18bfc996b3b9f5aa7b72c17ee1cb3491794d6e2ff7d9914525cdf2d88b931c505ef864d201d2b364a6e25ae4d183e738c3c86e53e5ad1a1918c815cb1bcd59b97d1a3cf9796687bac6a138b&quot;),</span><br><span class="line">       (b&quot;36000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f2b343c2bb614b7b4acc4e0ade8a5e4b2abb4eefe97ef7991832793e4e301637cf0becd84c43dbafeb43d0da12c8e2883e0d02ada60e678e3470ee866abe2fa713b8a521a986e75d821f74221fee2ea441b3ab462f29b56f862b00d05f60cdc1a9a1c92d04457bd6e693673963ab6e6b6c3552cd1c54efe627b342fecdfd8dea&quot;,b&quot;36000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f2b343c2bb614b7b4acc4e0ade8a5e4b2abb4e6fe97ef7991832793e4e301637cf0becd84c43dbafeb43d0da1248e3883e0d02ada60e678e3470ee066abe2fa713b8a521a986e75d821f74221fee2ea441b3abc62f29b56f862b00d05f60cdc1a9a1c92d04457bd6e6936739632b6e6b6c3552cd1c54efe627b3427ecdfd8dea&quot;),</span><br><span class="line">       (b&quot;370000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001d6afba61c0910b5ca21a9164b65134753b3845080d9afe6460237a1d938a8385204b0e85cce2b686b40d9b9c517e64b08ee01d02fa63470aa3b34c1e550d11356d867ea70e96b0257d9b1b20df1ee22603111180739001ad17bf6c8dd707932b34e97b62e74936197adcc2f93164b46c7c7e4bb7b6c1a55a21958961f7378be&quot;,b&quot;370000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001d6afba61c0910b5ca21a9164b65134753b384d080d9afe6460237a1d938a8385204b0e85cce2b686b40d9b9c597e64b08ee01d02fa63470aa3b3441e550d11356d867ea70e96b0257d9b1b20df1ee22603111980739001ad17bf6c8dd707932b34e97b62e74936197adcc2f93964a46c7c7e4bb7b6c1a55a21958161f7378be&quot;),</span><br><span class="line">       (b&quot;38000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c6eb639aedf271805029b40d4dc783ab8d769d35cb9032f9184641b94c881615f5f902cb5e8ba3176f2660d4f821828fdbed111365cc4dfbbf001ca884fcb74df4f681c17ed38f53b8346319fee0c2eaecf2ea2597f0ca2c04ed6c064e9e3ddd7d37ff3e54908e889a58455a8fd411bc0f75e93cadc453f6f89d16e8cd8e7c2a&quot;,b&quot;38000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000c6eb639aedf271805029b40d4dc783ab8d769db5cb9032f9184641b94c881615f5f902cb5e8ba3176f2660d4f8a1828fdbed111365cc4dfbbf001c2884fcb74df4f681c17ed38f53b8346319fee0c2eaecf2eaa597f0ca2c04ed6c064e9e3ddd7d37ff3e54908e889a58455a8f5411bc0f75e93cadc453f6f89d1668cd8e7c2a&quot;)]</span><br><span class="line"></span><br><span class="line">for i in range(8):</span><br><span class="line">    sh.sendline(msg[i][0])</span><br><span class="line">    sh.sendline(msg[i][1])</span><br><span class="line"></span><br><span class="line">sh.recvuntil(b&quot;Congrats! the flag: &quot;)</span><br><span class="line"></span><br><span class="line">print(sh.recvline())</span><br><span class="line"></span><br><span class="line">#CCTF&#123;mD5_h4Sh_cOlL!Si0N_CrYp7o_ch41lEnGe!!!&#125;</span><br></pre></td></tr></table></figure><h2 id="Beheaded"><a href="#Beheaded" class="headerlink" title="Beheaded$"></a>Beheaded$</h2><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The beheaded flags have had their headers removed, making them encrypted. Can a living entity truly survive without a head?</span><br></pre></td></tr></table></figure><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">source secrets.sh</span><br><span class="line"></span><br><span class="line">FLAGS=&quot;all_flags.txt&quot;</span><br><span class="line">rm -f &quot;all_flags.enc&quot;</span><br><span class="line"></span><br><span class="line">while read flag; do</span><br><span class="line">magick -background white -fill blue -pointsize 72 -size &quot;$X&quot;x&quot;$Y&quot; -gravity North caption:&quot;$flag&quot; flag.ppm</span><br><span class="line">tail -n +4 flag.ppm &gt; tail</span><br><span class="line">openssl enc -aes-256-ecb -pbkdf2 -nosalt -pass pass:&quot;$KEY&quot; -in tail &gt;&gt; &quot;all_flags.enc&quot;</span><br><span class="line">done &lt; &quot;$FLAGS&quot;</span><br></pre></td></tr></table></figure><p>题目将flag串写在图片上，然后对这张图片进行ECB加密，最后得到密文文件。<br>这个不太会，看春哥说是用工具，以后再说吧。</p><h2 id="Medium"><a href="#Medium" class="headerlink" title="Medium"></a>Medium</h2><h2 id="Alilbols"><a href="#Alilbols" class="headerlink" title="Alilbols"></a>Alilbols</h2><p>题目:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python3</span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from gmpy2 import *</span><br><span class="line">from secret import d, flag</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def genkey(d):</span><br><span class="line">    while True:</span><br><span class="line">        f = getRandomRange(1, int(sqrt(2) * 10 ** d))</span><br><span class="line">        g = getRandomRange(10 ** d, int(sqrt(2) * 10 ** d))</span><br><span class="line">        if gcd(f, 10 * g) == 1:</span><br><span class="line">            q = 4 * 100 ** d</span><br><span class="line">            h = inverse(f, q) * g % q</span><br><span class="line">            if gcd(h, 10 * d) == 1:</span><br><span class="line">                break</span><br><span class="line">    pkey, skey = (d, h), (f, g)</span><br><span class="line">    return pkey, skey</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def encrypt(m, pkey):</span><br><span class="line">    d, h = pkey</span><br><span class="line">    q = 4 * 100 ** d</span><br><span class="line">    assert m &lt; 10 ** d</span><br><span class="line">    r = getRandomRange(1, 10 ** d // 2)</span><br><span class="line">    c = (r * h + m + r) % q</span><br><span class="line">    return c</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pkey, _ = genkey(d)</span><br><span class="line">m = bytes_to_long(flag)</span><br><span class="line">c = encrypt(m, pkey)</span><br><span class="line"></span><br><span class="line">print(f&#x27;h = &#123;pkey[1]&#125;&#x27;)</span><br><span class="line">print(f&#x27;c = &#123;c&#125;&#x27;)</span><br></pre></td></tr></table></figure><p>output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h = 1051643987107349427988807326909852110640860009433515828832892541964729933410444984350917250524103015414239941369074041041830326426044333499878031164851095096864048639115431370526747014210332286314344073411522846701723463410585601251886732229726828022089809603850477551571014006202841406236367999378786782206165205893353928598469661871284779486855440579818275314024966224282757807716013799903830828885606714972634243850947534165272668985513949964901606268939300116019465522042467054120201087606016018354238401711720121586874288767235317479748890350702705575809130664969776549574720593740409234863974057904204809404816059921579771581800937241591669455683460570640868196509926763901079838233646036933530095891316054589051458146768287967886035091641162494322987627448810201550901588438560433001422233269632915351406169253963308421081459981594969405377353502889363324282815864766827664453823780238352371809048289845094882346227809082005375092441877966603138648719670349093616548820955566204871333952902983753935678447080673827214244142614295192263451840766771122229866931492260663320087497820892824540996643905125018452302747847009</span><br><span class="line">c = 11913143174789215053772744981113562063689725867199301496294410323568897757042952642806438602327917861884988292757318755590132189620231444302311290566584065812614959093870787195145654508262419270742989923415342357807325941686508030706603920412262004324188375072184983301522882728578077572816154054220606088703932092256905881975876112779175003897105313776239681492514925430817300633974666123599685062340158348009344351002327049272743679109535286730751345284084148118733529966364414749672437370878526710641430471595906340522772252875146681541656231708112317601000655090279925720590940060372738708208419449824043905057860829031242339842131799965043031307394209699264362321397162645220002253271689678364848888381499587038475895945238726252440250183268252483198408039250213490525880829604473555612305513974817850974135874728084839426045420913060975464553734293001460752648937744531874552694145500413222582269910431269597066268600572899619407093373565994271589940926018891922169454906132284552523035481664164354874071831210264979733079749696197917769435226866441989054017071332158916586376454753209296136133271926449919437888563234409</span><br></pre></td></tr></table></figure><p>密钥生成有：</p><ul><li>$ 1 \leq f &lt; \sqrt{2} \cdot 10 ^ d$</li><li>$ 10 ^ d \leq g &lt; \sqrt{2} \cdot 10 ^ d$</li><li>$ q = 4 \cdot 10 ^ 2d$</li><li>$ h = f ^ {-1} g \ (mod \ q)$</li></ul><p>加密有:</p><ul><li>取一个随机数r, 满足 $ 1 &lt; r &lt; \frac{10^d}{2}$</li><li>计算密文 $ c = rh + m + r \ (mod \ q) $</li></ul><p>给出了h,c, 需要还原m</p><p>很明显是NTRU，直接造格：<br>$\begin{bmatrix} r &amp; -1 &amp; k \end{bmatrix}$ <script type="math/tex">\begin{bmatrix} 1 & 0 & h+1 \\ 0 & 1 & c \\ 0 & 0 & q  \end{bmatrix}</script> = $\begin{bmatrix} r &amp; -1 &amp; -m \end{bmatrix}$</p><p>但是我们不知道d,q, 所以需要枚举一下d的大小</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">h = </span><br><span class="line">c = </span><br><span class="line"></span><br><span class="line">for d in range(500,800):</span><br><span class="line">    q = 4 * 10 ** (2 *d)</span><br><span class="line">    M = matrix(ZZ, [[2, 0, h+1],</span><br><span class="line">                [0, 10^d,c],</span><br><span class="line">                [0, 0,   q]])</span><br><span class="line">    v = M.LLL()[0] </span><br><span class="line">    m = int(abs(v[-1]))</span><br><span class="line">    if b&#x27;CCTF&#x27; in long_to_bytes(m):</span><br><span class="line">        print(d)</span><br><span class="line">        print(long_to_bytes(m))</span><br></pre></td></tr></table></figure><h2 id="Ally"><a href="#Ally" class="headerlink" title="Ally*"></a>Ally*</h2><p>题目描述： </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Ally enjoys the challenge of solving Diophantine equations, so help them tackle this latest complex equation as well.</span><br></pre></td></tr></table></figure><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from flag import flag</span><br><span class="line"></span><br><span class="line">def die(*args):</span><br><span class="line">pr(*args)</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">def pr(*args):</span><br><span class="line">s = &quot; &quot;.join(map(str, args))</span><br><span class="line">sys.stdout.write(s + &quot;\n&quot;)</span><br><span class="line">sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def sc():</span><br><span class="line">return sys.stdin.buffer.readline()</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">border = &quot;┃&quot;</span><br><span class="line">pr(        &quot;┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓&quot;)</span><br><span class="line">pr(border, &quot;.::  Ally is my best friend, help him to solve his tough task  ::.&quot;, border)</span><br><span class="line">pr(        &quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛&quot;)</span><br><span class="line"></span><br><span class="line">nbit = 14</span><br><span class="line">level, step = 0, 19</span><br><span class="line">while True:</span><br><span class="line">pr(border, f&#x27;Please send your &#123;nbit&#125;-bit prime:  &#x27;)</span><br><span class="line">p = sc().strip()</span><br><span class="line">try:</span><br><span class="line">p = int(p)</span><br><span class="line">except:</span><br><span class="line">die(border, &#x27;Your input is not valid! Bye!!!&#x27;)</span><br><span class="line">if isPrime(p) and p.bit_length() == nbit:</span><br><span class="line">pr(border, &#x27;Send the solution of the following Diophantine equation in positive integers x, y&#x27;)</span><br><span class="line">pr(border, f&#x27;&#123;p&#125; * (x - y)**3 = (x**2 + y) * (x + y**2)&#x27;)</span><br><span class="line">xy = sc().strip().decode()</span><br><span class="line">try:</span><br><span class="line">x, y = [int(_) for _ in xy.split(&#x27;,&#x27;)]</span><br><span class="line">except:</span><br><span class="line">die(border, &#x27;Your answer is not valid! Bye!!!&#x27;)</span><br><span class="line">if p * (x - y)**3 == (x**2 + y) * (x + y**2) and x &gt; 0 and y &gt; 0:</span><br><span class="line">if level == step:</span><br><span class="line">die(border, f&#x27;Congratz! You got the flag: &#123;flag&#125;&#x27;)</span><br><span class="line">else:</span><br><span class="line">pr(border, f&#x27;Good job, try the next step &#123;level + 2&#125;&#x27;)</span><br><span class="line">level += 1</span><br><span class="line">nbit = int(1.2*nbit) + getRandomRange(0, 6)</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;Your answer is not correct! Bye!!&#x27;)</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;Kidding me!? Bye!!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><ul><li>就是给出19对如下的丢番图方程的正整数解：<script type="math/tex; mode=display">p(x-y)^3 = (x^2 + y)(x+y^2)</script></li></ul><p>赛中没做出来，赛后发现其实:</p><script type="math/tex; mode=display">p = 4y+1x = 2y+1</script><p>就可以了</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">from pwn import *</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">def get_valid_prime(bits):</span><br><span class="line">    while True:</span><br><span class="line">        p = getPrime(bits)</span><br><span class="line">        if p % 4 == 1:</span><br><span class="line">            return p</span><br><span class="line"></span><br><span class="line">try:</span><br><span class="line">    sh = remote(&#x27;01.cr.yp.toc.tf&#x27;, 13777)</span><br><span class="line">    for i in range(20):</span><br><span class="line">        sh.recvuntil(b&#x27;Please send your &#x27;)</span><br><span class="line">        bit_length = sh.recvuntil(b&#x27;-&#x27;)[:-1]</span><br><span class="line">        bit_length = int(bit_length)</span><br><span class="line">        sh.recvline()</span><br><span class="line"></span><br><span class="line">        p = get_valid_prime(bit_length)</span><br><span class="line">        y = (p - 1) // 4</span><br><span class="line">        x = 2 * y + 1</span><br><span class="line"></span><br><span class="line">        sh.sendline(str(p).encode())</span><br><span class="line">        sh.recvline()</span><br><span class="line">        sh.sendline(f&#x27;&#123;x&#125;,&#123;y&#125;&#x27;.encode())</span><br><span class="line">        sh.recv()</span><br><span class="line"></span><br><span class="line">    print(sh.recvline())</span><br><span class="line">except Exception as e:</span><br><span class="line">    print(f&quot;发生错误: &#123;e&#125;&quot;)</span><br></pre></td></tr></table></figure><h2 id="Bada"><a href="#Bada" class="headerlink" title="Bada*"></a>Bada*</h2><p>题目描述:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Bada equation contains an undetermined function. By closely examining how this equation behaves, you may be able to discover the concealed flag.</span><br></pre></td></tr></table></figure><p>题目:</p><p>存在一个函数方程f: N×N → Z:</p><ul><li>$ f(a+1,b) = f(a,b) + a $</li><li>$ f(a,b+1) = f(a,b) - b $</li></ul><p>给定了f(x_0,y_0)的函数值，以及f（x,y）的值，求（x,y）使满足f(x,y)=z</p><p>很明显这两个函数方程可以看作两个等差数列，也就是有:</p><script type="math/tex; mode=display">f(x,y) =  f(1,1) + (1+2+...+(x-1)) - (1+2+...+(y-1))</script><p>即是：</p><script type="math/tex; mode=display">f(x,y) = f(1,1) + \frac{(x-1)(x)}{2} - \frac{(y-1)(y)}{2}</script><p>记f(1,1)为c<br>也就是有：</p><script type="math/tex; mode=display">f(x,y) = \frac{(x-1)(x)}{2} - \frac{(y-1)(y)}{2} + c</script><p>这里就把问题变成了解关于x和y的不定方程的问题:</p><script type="math/tex; mode=display">\begin{align*}2(z-c) &= x(x-1)- y(y-1) \\       &= (x-y)(x+y-1) \quad \text{} \\\end{align*}</script><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from Pwn4Sage.pwn import *</span><br><span class="line">import re</span><br><span class="line"></span><br><span class="line">context.log_level = &#x27;debug&#x27;</span><br><span class="line"></span><br><span class="line">class EquationSolver:</span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.pattern = r&#x27;f\((\d+), (\d+)\) = (-?\d+) and f\(x, y\) = (-?\d+)\n&#x27;</span><br><span class="line">        self.conn = remote(&#x27;node4.anna.nssctf.cn&#x27;, 28634)</span><br><span class="line"></span><br><span class="line">    def solve(self, prev_x, prev_y, base_z, target_z):</span><br><span class="line">        adjusted_z = base_z - (prev_x * (prev_x - 1) // 2) + (prev_y * (prev_y - 1) // 2)</span><br><span class="line">        left_hand = 8 * (target_z - adjusted_z)</span><br><span class="line">        for factor1 in divisors(left_hand):</span><br><span class="line">            factor2 = left_hand // factor1</span><br><span class="line">            if factor1 % 2 != 0 or factor2 % 2 != 0:</span><br><span class="line">                continue</span><br><span class="line">            half_factor1 = factor1 // 2</span><br><span class="line">            half_factor2 = (factor2 + 2) // 2</span><br><span class="line">            if (half_factor1 + half_factor2) % 2 != 0:</span><br><span class="line">                continue</span><br><span class="line">            x = (half_factor1 + half_factor2) // 2</span><br><span class="line">            y = (half_factor2 - half_factor1) // 2</span><br><span class="line">            return x, y</span><br><span class="line">        raise Exception(&quot;No solution found&quot;)</span><br><span class="line"></span><br><span class="line">    def process_step(self):</span><br><span class="line">        self.conn.recvuntil(b&#x27;We know: &#x27;)</span><br><span class="line">        line = self.conn.recvline().decode()</span><br><span class="line">        match = re.match(self.pattern, line)</span><br><span class="line">        if not match:</span><br><span class="line">            raise Exception(&quot;Format error in received data&quot;)</span><br><span class="line">        prev_x, prev_y, base_z, target_z = map(int, match.groups())</span><br><span class="line">        x, y = self.solve(prev_x, prev_y, base_z, target_z)</span><br><span class="line">        self.conn.sendline(f&quot;&#123;x&#125;,&#123;y&#125;&quot;.encode())</span><br><span class="line"></span><br><span class="line">    def run(self):</span><br><span class="line">        for _ in range(20):</span><br><span class="line">            self.process_step()</span><br><span class="line">        self.conn.interactive()</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    solver = EquationSolver()</span><br><span class="line">    solver.run()    </span><br></pre></td></tr></table></figure><h2 id="Duzly"><a href="#Duzly" class="headerlink" title="Duzly$"></a>Duzly$</h2><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Duzly is a straightforward hash function design based on congruence relationships over a prime number modulus.</span><br></pre></td></tr></table></figure><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from os import urandom</span><br><span class="line">from flag import flag</span><br><span class="line"></span><br><span class="line">def pad(m):</span><br><span class="line">m += b&#x27;\x8f&#x27; * (8 - len(m) % 8)</span><br><span class="line">return m</span><br><span class="line"></span><br><span class="line">def duzly(m, C):</span><br><span class="line">ow, E = 0, [2**24 + 17, 2**24 + 3, 3, 2, 1, 0]</span><br><span class="line">for _ in range(6):</span><br><span class="line">ow += C[_] * pow(m, E[_], p)</span><br><span class="line">return ow % p</span><br><span class="line"></span><br><span class="line">def pashan(msg):</span><br><span class="line">msg = pad(msg)</span><br><span class="line">pash, msg = b&#x27;&#x27;, [msg[8*i:8*(i+1)] for i in range(len(msg) // 8)]</span><br><span class="line">for m in msg:</span><br><span class="line">_h = duzly(bytes_to_long(m), C).to_bytes(8, &#x27;big&#x27;)</span><br><span class="line">pash += _h</span><br><span class="line">return pash</span><br><span class="line"></span><br><span class="line">p = 2**64 - 59</span><br><span class="line">C = [1] + [randint(0, p) for _ in range(5)]</span><br><span class="line">flag = urandom(getRandomRange(0, 110)) + flag + urandom(getRandomRange(0, 110))</span><br><span class="line">_pash = pashan(flag)</span><br><span class="line"></span><br><span class="line">f = open(&#x27;_pash_updated&#x27;, &#x27;wb&#x27;)</span><br><span class="line">f.write(str(C).encode() + b&#x27;\n&#x27;)</span><br><span class="line">f.write(_pash)</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure><p>赛中看0解（自知之明一手）就没看，赛后一看果然没看懂<br>这里贴一下大佬的做法<a href="https://www.github.com/Sarkoxed/ctf-writeups/tree/master/cryptoctf2024/duzly_updated">这里</a></p><h2 id="Forghan"><a href="#Forghan" class="headerlink" title="Forghan*"></a>Forghan*</h2><p>题目描述：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">The Forghan, the combination of RSA and DLP cryptography, may in certain instances prove more accessible than employing either method individually.</span><br></pre></td></tr></table></figure><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">import sys</span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">from hashlib import sha256</span><br><span class="line">from flag import flag</span><br><span class="line"></span><br><span class="line">def die(*args):</span><br><span class="line">pr(*args)</span><br><span class="line">quit()</span><br><span class="line"></span><br><span class="line">def pr(*args):</span><br><span class="line">s = &quot; &quot;.join(map(str, args))</span><br><span class="line">sys.stdout.write(s + &quot;\n&quot;)</span><br><span class="line">sys.stdout.flush()</span><br><span class="line"></span><br><span class="line">def sc():</span><br><span class="line">return sys.stdin.buffer.readline()</span><br><span class="line"></span><br><span class="line">def find_gen(p):</span><br><span class="line">while True:</span><br><span class="line">g = getRandomRange(2, p - 1)</span><br><span class="line">if pow(g, (p-1)//2 , p) != 1:</span><br><span class="line">return g</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">border = &quot;┃&quot;</span><br><span class="line">pr(        &quot;┏━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┓&quot;)</span><br><span class="line">pr(border, &quot;Hi all, now it&#x27;s time to solve a strange and unusual RSA and DLP    &quot;, border)</span><br><span class="line">pr(border, &quot;challenge about encryption! Follow the questions and find the secret&quot;, border)</span><br><span class="line">pr(border, &quot;flag! :)                                                            &quot;, border)</span><br><span class="line">pr(        &quot;┗━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┛&quot;)</span><br><span class="line">nbit, b = 256, False</span><br><span class="line">while True:</span><br><span class="line">pr(f&quot;| Options: \n|\t[G]et encrypted flag \n|\t[P]ublic parameters \n|\t[S]ubmit &#123;nbit&#125; primes \n|\t[Q]uit&quot;)</span><br><span class="line">ans = sc().decode().lower().strip()</span><br><span class="line">if ans == &#x27;g&#x27;:</span><br><span class="line">if b == True:</span><br><span class="line">l, n = len(flag), (p**2 - 1) * (q**2 - 1)</span><br><span class="line">gp, gq = find_gen(p), find_gen(q)</span><br><span class="line">sp, sq = getRandomRange(1, p), getRandomRange(1, q)</span><br><span class="line">flagp, flagq = flag[:l // 2], flag[l // 2:]</span><br><span class="line">yp, yq = pow(gp, sp, p), pow(gq, sq, q)</span><br><span class="line">cp, cq = pow(bytes_to_long(flagp), yp, n), pow(bytes_to_long(flagq), yq, n)</span><br><span class="line">pr(border, f&#x27;cp = &#123;cp&#125;&#x27;)</span><br><span class="line">pr(border, f&#x27;cq = &#123;cq&#125;&#x27;)</span><br><span class="line">else: pr(border, &#x27;Please first send your primes! :P&#x27;)</span><br><span class="line">elif ans == &#x27;s&#x27;:</span><br><span class="line">pr(border, &#x27;Send your desired prime numbers separated by comma: &#x27;)</span><br><span class="line">P = sc()</span><br><span class="line">try:</span><br><span class="line">p, q = P.split(b&#x27;,&#x27;)</span><br><span class="line">p, q = int(p), int(q)</span><br><span class="line">except: die(border, &#x27;Your input are not integer! Bye!!&#x27;)</span><br><span class="line">if p != q and isPrime(p) and isPrime(q) and p.bit_length() == q.bit_length() == nbit:</span><br><span class="line">b = True</span><br><span class="line">pr(border, &#x27;Now you can get the encrypted flag in main menu!&#x27;)</span><br><span class="line">else: die(border, &#x27;Sorry, your integers are not valid :/&#x27;)</span><br><span class="line">elif ans == &#x27;p&#x27;:</span><br><span class="line">if b == True:</span><br><span class="line">pr(border, f&#x27; gp = &#123;gp&#125;&#x27;)</span><br><span class="line">pr(border, f&#x27; gq = &#123;gq&#125;&#x27;)</span><br><span class="line">pr(border, f&#x27; yp = &#123;yp&#125;&#x27;)</span><br><span class="line">pr(border, f&#x27; yq = &#123;yq&#125;&#x27;)</span><br><span class="line">else: pr(border, &#x27;Please first send your primes! :P&#x27;)</span><br><span class="line">elif ans == &#x27;q&#x27;:</span><br><span class="line">die(border, &#x27;Quitting...&#x27;)</span><br><span class="line">else:</span><br><span class="line">die(border, &#x27;You should select valid choice!&#x27;)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">main()</span><br></pre></td></tr></table></figure><p>题目有三个选项，但是显然是有顺序的，具体来说应该按照下面来：<br>    选择”S”，输入256bit的素数p、q<br>    选择”G”，靶机对flag进行加密，加密流程如下：<br>        生成n，n = (p^2 - 1) * (q^2 - 1)<br>        分别生成p、q下的一个随机二次非剩余gp、gq<br>        生成p、q下的随机数sp、sq<br>        将flag分为两段，记为flagp、flagq，对应数字记为mp、mq<br>        计算yp、yq，$y<em>p = g_p^{s_p} \pmod{p}$ ， $y_q = g_q^{s_q} \pmod{q}$<br>        计算密文cp、cq，$c_p = m_p^{y</em> p} \pmod{n}$，$c_q = m_q^{y_q} \pmod{n}$</p><p>选择”P”，获取gp、gq、yp、yq的值</p><p>由于有 $y_p$、$y_q$，所以这里就变成了解一个RSA的问题，由于flag是静态的，所以可以放在一个子群里去求解，放在模p-1下有：</p><script type="math/tex; mode=display">c_p = m_p^{y_p} \pmod{p-1}</script><script type="math/tex; mode=display">c_q = m_q^{y_q} \pmod{q-1}</script><p>由于p和q都是自己构造的，很容就能得到p-1的分解，就可以解RSA解出mp、mq在p-1下的值，又因为flag是静态的，所以完全可以多次交互求crt</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from sympy.ntheory.modular import crt</span><br><span class="line">from pwn import *</span><br><span class="line"></span><br><span class="line">sh = remote(&quot;node4.anna.nssctf.cn&quot;, 28932)</span><br><span class="line"></span><br><span class="line">def gen_prime():</span><br><span class="line">    while True:</span><br><span class="line">        p = getPrime(255)</span><br><span class="line">        if isPrime(2*p+1):</span><br><span class="line">            return 2*p+1</span><br><span class="line"></span><br><span class="line">nums = 10</span><br><span class="line">P = [gen_prime() for i in range(nums)]</span><br><span class="line">mp = []</span><br><span class="line">mq = []</span><br><span class="line">for i in range(nums):</span><br><span class="line">    sh.sendline(b&quot;s&quot;)</span><br><span class="line">    sh.recvuntil(b&#x27;Send your desired prime numbers separated by comma: &#x27;)</span><br><span class="line">    q = getPrime(256)</span><br><span class="line">    sh.sendline((str(P[i]) + &#x27;,&#x27; + str(q)).encode())</span><br><span class="line"></span><br><span class="line">    sh.sendline(b&quot;g&quot;)</span><br><span class="line">    sh.recvuntil(b&quot;cp = &quot;)</span><br><span class="line">    cp = int(sh.recvline().strip().decode())</span><br><span class="line">    sh.recvuntil(b&quot;cq = &quot;)</span><br><span class="line">    cq = int(sh.recvline().strip().decode())</span><br><span class="line"></span><br><span class="line">    sh.sendline(b&quot;p&quot;)</span><br><span class="line">    sh.recvuntil(b&quot;gp = &quot;)</span><br><span class="line">    gp = int(sh.recvline().strip().decode())</span><br><span class="line">    sh.recvuntil(b&quot;gq = &quot;)</span><br><span class="line">    gq = int(sh.recvline().strip().decode())</span><br><span class="line">    sh.recvuntil(b&quot;yp = &quot;)</span><br><span class="line">    yp = int(sh.recvline().strip().decode())</span><br><span class="line">    sh.recvuntil(b&quot;yq = &quot;)</span><br><span class="line">    yq = int(sh.recvline().strip().decode())</span><br><span class="line"></span><br><span class="line">    k = (P[i] - 1) // 2</span><br><span class="line">    mp.append(pow(cp, inverse(yp, k - 1), P[i]))</span><br><span class="line">    mq.append(pow(cq, inverse(yq, k - 1), P[i]))</span><br><span class="line"></span><br><span class="line">Mp = crt(P, mp)[0]</span><br><span class="line">Mq = crt(P, mq)[0]</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(Mp))</span><br><span class="line">print(long_to_bytes(Mq))</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> crypto - write_up </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>开启记录之旅</title>
      <link href="/2024/12/03/2024-crypto-wp-%E8%AF%B4%E6%98%8E/"/>
      <url>/2024/12/03/2024-crypto-wp-%E8%AF%B4%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<!-- ---title: 文章标题date: 创建日期updated: 更新日期cover: 文章封面description: 文章描述swiper_index: 1 #置顶轮播图顺序，非负整数，数字越大越靠前--- --><h1 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h1><p>这算是真正的第一篇文章，此分类主要致力于记录我参与或复现各类比赛的题目，同时也会记下我在过程中遭遇的问题以及突发的奇思妙想。倘若存在错误或者有其他更佳的思路,热烈欢迎各位师傅予以指正。</p><p>我也学习一下鸡块师傅的做法：</p><ul><li>赛中做出的题目,名字无变化。</li><li>赛中未做出赛后复现的标 *。</li><li>赛中未做出，赛后也没有思路的标 $。 </li></ul>]]></content>
      
      
      <categories>
          
          <category> crypto - write_up </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>2024-强网杯-wp</title>
      <link href="/2024/12/03/2024-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/"/>
      <url>/2024/12/03/2024-%E5%BC%BA%E7%BD%91%E6%9D%AF-wp/</url>
      
        <content type="html"><![CDATA[<h2 id="EasyRSA"><a href="#EasyRSA" class="headerlink" title="EasyRSA"></a>EasyRSA</h2><p>题目描述：</p><pre><code>easy的RSA。</code></pre><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">#encoding:utf-8</span><br><span class="line">from Crypto.Util.number import long_to_bytes, bytes_to_long, getPrime</span><br><span class="line">import random, gmpy2</span><br><span class="line"></span><br><span class="line">class RSAEncryptor:</span><br><span class="line">def __init__(self):</span><br><span class="line">self.g = self.a = self.b = 0</span><br><span class="line">self.e = 65537</span><br><span class="line">self.factorGen()</span><br><span class="line">self.product()</span><br><span class="line"></span><br><span class="line">def factorGen(self):</span><br><span class="line">while True:</span><br><span class="line">self.g = getPrime(500)</span><br><span class="line">while not gmpy2.is_prime(2*self.g*self.a+1):</span><br><span class="line">self.a = random.randint(2**523, 2**524)</span><br><span class="line">while not gmpy2.is_prime(2*self.g*self.b+1):</span><br><span class="line">self.b = random.randint(2**523, 2**524)</span><br><span class="line">self.h = 2*self.g*self.a*self.b+self.a+self.b</span><br><span class="line">if gmpy2.is_prime(self.h):</span><br><span class="line">self.N = 2*self.h*self.g+1</span><br><span class="line">print(len(bin(self.N)))</span><br><span class="line">return</span><br><span class="line"></span><br><span class="line">def encrypt(self, msg):</span><br><span class="line">return gmpy2.powmod(msg, self.e, self.N)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def product(self):</span><br><span class="line">with open(&#x27;/flag&#x27;, &#x27;rb&#x27;) as f:</span><br><span class="line">self.flag = f.read()</span><br><span class="line">self.enc = self.encrypt(self.flag)</span><br><span class="line">self.show()</span><br><span class="line">print(f&#x27;enc=&#123;self.enc&#125;&#x27;)</span><br><span class="line"></span><br><span class="line">def show(self):</span><br><span class="line">print(f&quot;N=&#123;self.N&#125;&quot;)</span><br><span class="line">print(f&quot;e=&#123;self.e&#125;&quot;)</span><br><span class="line">print(f&quot;g=&#123;self.g&#125;&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">RSAEncryptor()</span><br></pre></td></tr></table></figure><p>其中有：</p><pre><code>            p = 2ga + 1            q = 2gb + 1</code></pre><p>很明显的Common Prime RSA攻击,又因为泄露了g，找到解密脚本直接套用即可</p><p><a href="https://hasegawaazusa.github.io/common-prime-rsa.html#%E5%B7%B2%E7%9F%A5-g" style="color: blue; text-decoration: underline;">Common Prime RSA 笔记 | 独奏の小屋 (hasegawaazusa.github.io)</a></p><p>因为这个博客的时间有点久了，sage版本比较老，bags的参数有点问题，参考sage的官方文档改一下bsgs参数就好。</p><p>exp：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#sage</span><br><span class="line">n=18609249586511447022929188601029606630816796460795187470065452150283160549624372398383148374249992521068549349516037511009027303530058706112191091689108542770802393390942693648814845389265858611340109158309645284100825624911741650444467173946569096983438455034895955228543351436008546035535031019474847660151534447157873386841134028651786166708821300066332734338450150803713659027324704224480646285707278634645234095122804559045312923819794776928194098487972764363649361713512731460059740929840789043447155551107435766468071813945331313861835289050624825980714650042186547867057986370794200778277570803957071502251887</span><br><span class="line">e=65537</span><br><span class="line">g=2157382166227048008151606160068683153029902706798753603550075684775242674106840467207794609506075603345430902709796320595040305496549488048759451499003</span><br><span class="line">enc=1706676139782916859705617140716929473350550599143215409850324617375385155893376548401557158261122335220199922229225746433590875391358929714141838314015655361989993985070285957305126847445442699828095001203266978036575956723172054402632901673504599481917025056824986547174258708944098866240451432510310007060414500907941107101001004474036283249456230343043785187819423163986135104740039129111213967847515011092231384245986891933365405336421413444499204268699546739391271911481490278065027465465222639265899471823742196086481403499948301061349936225773314002398442541447810628796808530412232638250097430811300924120316</span><br><span class="line">gamma = 500/(1024*2)</span><br><span class="line">cbits = ceil(nbits * (0.5 - 2 * gamma))</span><br><span class="line"></span><br><span class="line">M = (N - 1) // (2 * g)</span><br><span class="line">u = M // (2 * g)</span><br><span class="line">v = M - 2 * g * u</span><br><span class="line">GF = Zmod(N)</span><br><span class="line">x = GF.random_element()</span><br><span class="line">y = x ^ (2 * g)</span><br><span class="line">#c的范围大概与N^(0.5-2*gamma)很接近</span><br><span class="line">c = bsgs(y, y ^ u, (2**(cbits-1), 2**(cbits+1)), operation=&#x27;*&#x27;)</span><br><span class="line">#(a, b, bounds, operation=&#x27;*&#x27;, identity=None, inverse=None, op=None)</span><br><span class="line">ab = u - c</span><br><span class="line">apb = v + 2 * g * c</span><br><span class="line">P.&lt;x&gt; = ZZ[]</span><br><span class="line">f = x ^ 2 - apb * x + ab</span><br><span class="line">a = f.roots()</span><br><span class="line">if a:</span><br><span class="line">    a, b = a[0][0], a[1][0]</span><br><span class="line">    p = 2 * g * a + 1</span><br><span class="line">    q = 2 * g * b + 1</span><br><span class="line">    assert p * q == N</span><br><span class="line"></span><br><span class="line">from Crypto.Util.number import *</span><br><span class="line">print(long_to_bytes(int(pow(enc,inverse(e,(p-1)*(q-1)),n))))</span><br></pre></td></tr></table></figure><h2 id="apbq"><a href="#apbq" class="headerlink" title="apbq"></a>apbq</h2><p>题目描述：</p><pre><code>I obtained several sets of ap + bq through channel measurement. Can you solve it?</code></pre><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">from secrets import flag</span><br><span class="line">from math import ceil</span><br><span class="line">import sys</span><br><span class="line"></span><br><span class="line">class RSA():</span><br><span class="line">    def __init__(self, privatekey, publickey):</span><br><span class="line">        self.p, self.q, self.d = privatekey</span><br><span class="line">        self.n, self.e = publickey</span><br><span class="line"></span><br><span class="line">    def encrypt(self, plaintext):</span><br><span class="line">        if isinstance(plaintext, bytes):</span><br><span class="line">            plaintext = bytes_to_long(plaintext)</span><br><span class="line">        ciphertext = pow(plaintext, self.e, self.n)</span><br><span class="line">        return ciphertext</span><br><span class="line"></span><br><span class="line">    def decrypt(self, ciphertext):</span><br><span class="line">        if isinstance(ciphertext, bytes):</span><br><span class="line">            ciphertext = bytes_to_long(ciphertext)</span><br><span class="line">        plaintext = pow(ciphertext, self.d, self.n)</span><br><span class="line">        return plaintext</span><br><span class="line"></span><br><span class="line">def get_keypair(nbits, e = 65537):</span><br><span class="line">    p = getPrime(nbits//2)</span><br><span class="line">    q = getPrime(nbits//2)</span><br><span class="line">    n = p * q</span><br><span class="line">    d = inverse(e, n - p - q + 1)</span><br><span class="line">    return (p, q, d), (n, e)</span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:</span><br><span class="line">    pt = &#x27;./output.txt&#x27;</span><br><span class="line">    fout = open(pt, &#x27;w&#x27;)</span><br><span class="line">    sys.stdout = fout</span><br><span class="line"></span><br><span class="line">    block_size = ceil(len(flag)/3)</span><br><span class="line">    flag = [flag[i:i+block_size] for i in range(0, len(flag), block_size)]</span><br><span class="line">    e = 65537</span><br><span class="line"></span><br><span class="line">    print(f&#x27;[+] Welcome to my apbq game&#x27;)</span><br><span class="line">    # stage 1</span><br><span class="line">    print(f&#x27;┃ stage 1: p + q&#x27;)</span><br><span class="line">    prikey1, pubkey1 = get_keypair(1024)</span><br><span class="line">    RSA1 = RSA(prikey1, pubkey1)</span><br><span class="line">    enc1 = RSA1.encrypt(flag[0])</span><br><span class="line">    print(f&#x27;┃ hints = &#123;prikey1[0] + prikey1[1]&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey1&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc1 = &#123;enc1&#125;&#x27;)</span><br><span class="line">    print(f&#x27;----------------------&#x27;)</span><br><span class="line"></span><br><span class="line">    # stage 2</span><br><span class="line">    print(f&#x27;┃ stage 2: ai*p + bi*q&#x27;)</span><br><span class="line">    prikey2, pubkey2 = get_keypair(1024)</span><br><span class="line">    RSA2 = RSA(prikey2, pubkey2)</span><br><span class="line">    enc2 = RSA2.encrypt(flag[1])</span><br><span class="line">    kbits = 180</span><br><span class="line">    a = [getRandomNBitInteger(kbits) for i in range(100)]</span><br><span class="line">    b = [getRandomNBitInteger(kbits) for i in range(100)]</span><br><span class="line">    c = [a[i]*prikey2[0] + b[i]*prikey2[1] for i in range(100)]</span><br><span class="line">    print(f&#x27;┃ hints = &#123;c&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc2 = &#123;enc2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;----------------------&#x27;)</span><br><span class="line"></span><br><span class="line">    # stage 3</span><br><span class="line">    print(f&#x27;┃ stage 3: a*p + q, p + bq&#x27;)</span><br><span class="line">    prikey3, pubkey3 = get_keypair(1024)</span><br><span class="line">    RSA3 = RSA(prikey3, pubkey3)</span><br><span class="line">    enc3 = RSA2.encrypt(flag[2])</span><br><span class="line">    kbits = 512</span><br><span class="line">    a = getRandomNBitInteger(kbits)</span><br><span class="line">    b = getRandomNBitInteger(kbits)</span><br><span class="line">    c1 = a*prikey3[0] + prikey3[1]</span><br><span class="line">    c2 = prikey3[0] + b*prikey3[1] </span><br><span class="line">    print(f&#x27;┃ hints = &#123;c1, c2&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ public key = &#123;pubkey3&#125;&#x27;)</span><br><span class="line">    print(f&#x27;┃ enc3 = &#123;enc3&#125;&#x27;)</span><br></pre></td></tr></table></figure><h3 id="part1"><a href="#part1" class="headerlink" title="part1"></a>part1</h3><p>给出了 p + q和n，没什么好说的直接就能解</p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line"></span><br><span class="line">hint1 = 18978581186415161964839647137704633944599150543420658500585655372831779670338724440572792208984183863860898382564328183868786589851370156024615630835636170</span><br><span class="line">n1, e1 = (89839084450618055007900277736741312641844770591346432583302975236097465068572445589385798822593889266430563039645335037061240101688433078717811590377686465973797658355984717210228739793741484666628342039127345855467748247485016133560729063901396973783754780048949709195334690395217112330585431653872523325589, 65537)</span><br><span class="line">enc1 = 23664702267463524872340419776983638860234156620934868573173546937679196743146691156369928738109129704387312263842088573122121751421709842579634121187349747424486233111885687289480494785285701709040663052248336541918235910988178207506008430080621354232140617853327942136965075461701008744432418773880574136247</span><br><span class="line"></span><br><span class="line">print(long_to_bytes(int(pow(enc1, inverse(e, (n - hint1 + 1)), n1)))) </span><br></pre></td></tr></table></figure><h3 id="part2"><a href="#part2" class="headerlink" title="part2"></a>part2</h3><p>题目给出了 $h_i = a_ip+b_iq$<br>由于$a_i$和$b_i$都是小量所以很容易想到构造格来规约<br>给了100组式子，我们利用前两组和剩下的98组来消元：<br>$a_1a_ib_2h_1 - a_1a_2b_ih_1 - a_1a_ib_1h_2 + a_1^2b_ih_2 + a_1a_2b_1h_i + a_1^2b_2h_i = 0$</p><p>我们可以发现有公共系数a1所以有：<br>$a_ib_2h_1 - a_2b_ih_1 - a_ib_1h_2 + a_1b_ih_2 + a_2b_1h_i + a_1b_2h_i = 0$</p><p>提取出来系数有：<br>$(a_ib_2 - a_2b_i)h_1 - (a_ib_1 + a_1b_i)h_2 + (a_2b_1 + a_1b_2)h_i = 0$</p><p>参考maple的做法，大致思路是把这三个等式做groebner_basis，由于等式不够，所以肯定不能得到a、b的值，但是却可以得到a、b的线性等式，因此可以再做一次LLL后gcd解决：<a href="https://blog.maple3142.net/2023/09/03/downunderctf-2023-writeups/?highlight=apbq#apbq-rsa-ii" style="color: blue; text-decoration: underline;">DownUnderCTF 2023 Writeups</a><br>参考官方wp：<a herf= " https://my-ctf-challenges/downunderctf-2023/apbq-rsa-ii/solve/solv.sage at main · josephsurin/my-ctf-challenges" style="color: blue; text-decoration: underline;">官方wp</a></p><p>exp(这里主要参考了官方wp):</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">from Crypto.Util.number import *</span><br><span class="line">import gmpy2</span><br><span class="line">import itertools</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def find_factor(n, hints):</span><br><span class="line"></span><br><span class="line">V = hints[:4]</span><br><span class="line">k = 2^800</span><br><span class="line">M = Matrix.column([k * v for v in V]).augment(Matrix.identity(len(V)))</span><br><span class="line">B = [b[1:] for b in M.LLL()]</span><br><span class="line">M = (k * Matrix(B[:len(V)-2])).T.augment(Matrix.identity(len(V)))</span><br><span class="line">B = [b[-len(V):] for b in M.LLL() if set(b[:len(V)-2]) == &#123;0&#125;]</span><br><span class="line"></span><br><span class="line">for s, t in itertools.product(range(4), repeat=2):</span><br><span class="line">    T = s*B[0] + t*B[1]</span><br><span class="line">    a1, a2, a3, a4 = T</span><br><span class="line">    kq = gcd(a1 * hints[1] - a2 * hints[0], n)</span><br><span class="line">    if 1 &lt; kq &lt; n:</span><br><span class="line">        print(&#x27;find!&#x27;, kq, s, t)</span><br><span class="line">        return kq</span><br><span class="line"></span><br><span class="line">return None</span><br><span class="line"></span><br><span class="line">def simplify_factor(kq):</span><br><span class="line">    </span><br><span class="line">    for i in range(2**16, 1, -1):</span><br><span class="line">        if kq % i == 0:</span><br><span class="line">            kq //= i</span><br><span class="line">    return kq</span><br><span class="line"></span><br><span class="line">hints = []</span><br><span class="line">n, e = (, 0x10001)</span><br><span class="line">enc2 = 0</span><br><span class="line"></span><br><span class="line">kq = find_factor(n, hints)</span><br><span class="line"></span><br><span class="line">if kq:</span><br><span class="line">    q = int(simplify_factor(kq))</span><br><span class="line">    p = int(n // q)</span><br><span class="line">    d = inverse(e, -1, (p - 1) * (q - 1))</span><br><span class="line">    m = pow(enc2, d, n)</span><br><span class="line">    flag2 = long_to_bytes(m).decode()</span><br><span class="line">    print(flag2)</span><br></pre></td></tr></table></figure><h3 id="part3"><a href="#part3" class="headerlink" title="part3"></a>part3</h3><p>题目出的出问题了用了第二部分的私钥就能解密</p><p>题目给出了：<br>    $c_1 = ap + q$<br>    $c_2 = p + bq$</p><p>很明显有：<br>    $(c_1-q)(c_2-p) = 0 (mod n)$</p><p>展开有：<br>    $c_1c_2 - c_1p - c_2q = 0 (mod n)$</p><p>我们可以有：<br>    $c_1c_2-c_1(2^2 p_h+i)-c_2(2^2 q_h+j) = 0 (mod n)$</p><p>这里参考了鸡块师傅：<mark><a href="https://tangcuxiaojikuai.xyz/post/df3f7032.html#more">https://tangcuxiaojikuai.xyz/post/df3f7032.html#more</a></mark></p><p>exp:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">hint3 = (, )</span><br><span class="line">n3,e3 = (, 65537)</span><br><span class="line">enc3 = </span><br><span class="line">c1,c2 = hint3</span><br><span class="line"></span><br><span class="line">brute = 2</span><br><span class="line">for i in range(2^brute):</span><br><span class="line">    for j in range(2^brute):</span><br><span class="line">        L = Matrix(ZZ, [</span><br><span class="line">            [1,0,0,2^brute*c1],</span><br><span class="line">            [0,1,0,2^brute*c2],</span><br><span class="line">            [0,0,2^(512-brute),c1*i+c2*j-c1*c2],</span><br><span class="line">            [0,0,0,n3]</span><br><span class="line">        ])</span><br><span class="line">        L[:,-1:] *= n3</span><br><span class="line">        res = L.LLL()[0]</span><br><span class="line"></span><br><span class="line">        p = 2^brute*abs(res[0])+i</span><br><span class="line">        if(n3 % p == 0):</span><br><span class="line">            print(p)</span><br></pre></td></tr></table></figure><h2 id="21step"><a href="#21step" class="headerlink" title="21step"></a>21step</h2><p>题目描述<br>    weight it in 21 steps!</p><p>题目：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import re</span><br><span class="line">import random</span><br><span class="line">from secrets import flag</span><br><span class="line">print(f&#x27;Can you weight a 128 bits number in 21 steps&#x27;)</span><br><span class="line">pattern = r&#x27;([AB]|\d+)=([AB]|\d+)(\+|\-|\*|//|&lt;&lt;|&gt;&gt;|&amp;|\^|%)([AB]|\d+)&#x27;</span><br><span class="line"></span><br><span class="line">command = input().strip()</span><br><span class="line">assert command[-1] == &#x27;;&#x27;</span><br><span class="line">assert all([re.fullmatch(pattern, i) for i in command[:-1].split(&#x27;;&#x27;)])</span><br><span class="line"></span><br><span class="line">step = 21</span><br><span class="line">for i in command[:-1].split(&#x27;;&#x27;):</span><br><span class="line">    t = i.translate(str.maketrans(&#x27;&#x27;, &#x27;&#x27;, &#x27;=AB0123456789&#x27;))</span><br><span class="line">    if t in [&#x27;&gt;&gt;&#x27;, &#x27;&lt;&lt;&#x27;, &#x27;+&#x27;, &#x27;-&#x27;, &#x27;&amp;&#x27;, &#x27;^&#x27;]:</span><br><span class="line">        step -= 1</span><br><span class="line">    elif t in [&#x27;*&#x27;, &#x27;/&#x27;, &#x27;%&#x27;]:</span><br><span class="line">        step -= 3</span><br><span class="line">if step &lt; 0:exit()</span><br><span class="line"></span><br><span class="line">success = 0</span><br><span class="line">w = lambda x: sum([int(i) for i in list(bin(x)[2:])])</span><br><span class="line">for _ in range(100):</span><br><span class="line">    A = random.randrange(0, 2**128)</span><br><span class="line">    wa = w(A)</span><br><span class="line">    B = 0</span><br><span class="line">    try : exec(&quot;global A; global B;&quot; + command)</span><br><span class="line">    except : exit()</span><br><span class="line">    if A == wa:</span><br><span class="line">        success += 1</span><br><span class="line"></span><br><span class="line">if success == 100:</span><br><span class="line">    print(flag)</span><br></pre></td></tr></table></figure><p>在赛中的时候是硬想，通过按位与操作来筛选数据<br>通过与1010….,11001100….,11110000……,的按位与操作筛选出A的1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">B=A&gt;&gt;1;B=B&amp;113427455640312821154458202477256070485;A=A-B;B=A&amp;68056473384187692692674921486353642291;A=A&gt;&gt;2;A=A&amp;68056473384187692692674921486353642291;A=A+B;B=A&gt;&gt;4;A=A+B;A=A&amp;20016609818878733144904388672456953615;B=A&gt;&gt;8;A=A+B;B=A&gt;&gt;16;A=A+B;B=A&gt;&gt;32;A=A+B;B=A&gt;&gt;64;A=A+B;A=A&amp;127;</span><br></pre></td></tr></table></figure><p>在赛后看鸡块师傅的博客才知道有：<mark><a href="https://stackoverflow.com/questions/15233121/calculating-hamming-weight-in-o1">https://stackoverflow.com/questions/15233121/calculating-hamming-weight-in-o1</a></mark></p>]]></content>
      
      
      <categories>
          
          <category> crypto - write_up </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
